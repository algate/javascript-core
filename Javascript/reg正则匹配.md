```javascript
// 汉字字符匹配：
var nameReg = /^[\u4E00-\u9FA5]{2,5}(?:·[\u4E00-\u9FA5]{1,26})*$/
// 正则匹配电话：
reg=/^(([+]{0,1}\d{3,4}[ ]?-[ ]?\d{7,8}|\d{11})\s*)*$/
// 简易电话：
/^1[34578]\d{9}$/
// 邮箱验证：
var mainReg = /^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/;
// 身份证验证：
var reg = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
// 学号匹配：
var reg = /\d+/;
```

## defautl:

```html
RegExp
<1>对于exec方法：设置了全局g，每次调用exec()方法都会在字符串中继续查找新的匹配项,lastIndex属性值每次调用都会增加，直到找不到null,lastIndex==0;
如果不设置全局g,在一个字符串多次调用exec()方法返回的都是第一次匹配的信息，lastIndex==0;
<2>exec、match--不加g没有什么区别(exec的lastIndex永远是0)加上g则match忽略分组直接把总正则全部找出来；
    i--ignoreCase忽略大小写
    m--multiline分行和多行查找(m和表示开头^的元字符一起用才有意义)
元字符：
\d--所有的数字
\w--包括下划线的所有单词字符[a-z][A-Z][0-9]_
\s--任何空白字符(空格，制表符，换页符)
\b--边界boundary;
\n--换行
\t--制表符
.--除换行回车之外的一切字符如果想匹配本身，要加转义字符
表示位置和数量的：^$,+*?{m,n},{m}{m,}
/4+/--/4{1,}/
/4?/--/4{0,1}/
/4*/--/4{0,}/
/4{7}/----连续的7个4
/^4{7}$/----严格匹配7个4，不能出现其他字符

```

> **《1》** `/\d/;==/[0-9]/;[]--表示或--[0-11]`表示从 0 到 1 和 1 不是 11；
> **《2》** `alert(RegExp,$1);`找出存储在 regexp 中的第一个数据`$2`表示第二个;
> **《3》** `/\w/;==/[A-Z][a-z][0-9]_-/;`--要把减号当做字符，要放在中括号中的最后(或者最 前);
> **《4》** `reg=/^[.\n]$/;`带`\`的元字符在`[]`里还是元字符，但是不带`\`的元字符就已经表示此字符了;
> **《5》** `/[^0-9]/^`出现在[]中的第一个位置，表示"非";
> **《6》** 正则表达式的所有元字符都必须转义：元字符包括:` ( [ { \ ^ $ | ) ? * + . ] }`想要匹配字符串中的这些字符就必须进行转义;
> **《7》** 元字符的另一种表示方式(字符串)：------字符串中,`"\"`反斜杠要写成`"\\"`否则把"转义了；
> 字符\在字符串中通常被转义为而在正字表达式字符串中就会变成`\\\\`
> `var reg=new RegExp("\\d");` >**《8》** ()--子表达式，分组
> `/(子正则表达式)\1/`;
> `?:`--表示匹配不捕获`/((?:\d)+1+)/;`
> `woow,4004--reg=/^(\w)(\w)\2\1$/--\2`指的是位置不是数量(子正则表达式位置)相对应重复

## 分组应用

```javascript
<--第一个方法-->
// 没有分组的话传递三个参数(匹配的结果,匹配到的索引位置,原有的字符串)
var str="23209340928";
    var reg=/^(\d{1,3})((?:\d{3})+)$/;
    // 传递六个参数，?:表示不需要捕获
var str1=str.replace(reg,function(ar0,ar1,ar2){
    //第一个参数是总正则匹配到的结果
    //第二个参数是第一个子正则匹配到的结果
    //……
    //倒数第二个参数是总正则在原字符串种匹配到的索引位置
    //原来的字符串
    return ar1+ar2.replace(/\d{3}/g,function(rs){
        return ","+rs;
    });
});
// <--第二个方法-->
var str2=str.replace(/\d/g,function(r,i){
    var n=(str.length-1-i)%3;
    if(n==0&&str.length-1-i>0){
        return r+",";
    }
    else{
        return r;
    };
});
// <--第三个方法-->
var strTemp=str.split("").reverse().join("");
//?=pattern正向预查要匹配的字符串后面必须紧跟着pattern
var str3=strTemp.replace(/(\d{3})(?!$)/g,"$1,");
//最后末尾加了一个逗号，倒过来首位就多了一个逗号
str3=str3.split("").reverse().join("");
//正向预查，负向预查
//得到的结尾处有","----正向预查(最后必须满足三位)
```

#### ?: ?=和?!--匹配不捕获

`?=pattern`--正向预查要匹配的字符串后面必须紧跟 pattern
`(?!$)`当匹配到最后末尾是结尾的时候，才匹配；
形式：`(?=pattern)` 所谓正向预查，意思就是：要匹配的字符串，后面必须紧跟着`pattern`！ 我们知道正则表达式/cainiao/会匹配 cainiao。同样，也会匹配 cainiao9 中的 cainiao。但是我们可能希望，cainiao 只能匹配 cainiao8 中的 cainiao
`?!pattern`--反向预查要匹配的字符串后面不能紧跟着 pattern
(?1$)当匹配的字符串末尾不是结束的时候就会匹配，直到末·尾为结束时不再匹配；
形式`(?!pattern)`和`?=`恰好相反，要求字符串的后面不能紧跟着某个 pattern

```javascript
var str = "232093409280";
var reg = /^(\d{1,3})((?:\d{3})+)$/;
var strTemp = str.split("").reverse().join("");
var str3 = strTemp.replace(/(\d{3})(?!$)/g, "$1,");
//匹配的字符串不再末尾就执行，匹配遇到末尾就不匹配了；
str3 = str3.split("").reverse().join("");
console.log(str3);
```

```javascript
匹配空白行的正则表达式：\n\s*\r
匹配中文字符的正则表达式： [\u4e00-\u9fa5]
匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />
匹配首尾空白字符的正则表达式：^\s*|\s*$
匹配特定数字：
　　^[1-9]d*$　 　 //匹配正整数
　　^-[1-9]d*$ 　 //匹配负整数
　　^-?[1-9]d*$　　 //匹配整数
　　^[1-9]d*|0$　 //匹配非负整数（正整数 + 0）
　　^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0）
　　^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数
　　^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数
　　^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数
　　^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
　　^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
匹配特定字符串：
　　^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
　　^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
　　^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
　　^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
　　^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串
```

应用：javascript 中没有像 vbscript 那样的 trim 函数，我们就可以利用这个表达式来实现

```javascript
String.prototype.trim = function () {
    return this.replace(/(^s*)|(s*$)/g, "");
};
```
