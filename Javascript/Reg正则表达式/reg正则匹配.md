# RegExp
## 使用方法:
1. RegExp对象方法（两个）:`exce()`和`test()`
语法：`RegExpObject.exec(string)`;
  >exec() 方法用于检索字符串中的正则表达式的匹配，如果字符串中有匹配的值返回该匹配值构成的数组 ，且该数组还有继承的属性：
  index：表示第一个匹配的字符在原字符串中的位置，input:表示原字符串，groups：表示当初中命名的分组时匹配到的分组对象；
  exec()方法没有匹配到数据时返回 null。

  >test()方法用于检测一个字符串是否匹配某个模式；如果字符串中有匹配的值返回 true ，否则返回 false。

2. 支持正则表达式的String对象的方法:search()、replace()、split()、match()
  >search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。
  如果找到任何匹配的子串，则返回 该子串在原字符串中的第一次出现的位置。
  如果没有找到任何匹配的子串，则返回 -1。

  >replace()方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。原字符串不变，创建一个新的字符串。
  创建一个新的字符串，原字符串不变。

  >split()方法用于把一个字符串按符合匹配条件的方式分割成一个字符串数组。不改变原字符串

  >match()方法match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配
  >**注意：** 
  match() 方法将检索字符串 String，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。
  如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配，与exce的完全一致。
  如果 regexp 有标志 g，它将找到全部符合正则子字符串，并返回一个数组。
  如果没有找到任何匹配的文本，无论有没有g，match() 将返回 null。

## default:
```html
<1>对于exec方法：设置了全局g，每次调用exec()方法都会在字符串中继续查找新的匹配项,lastIndex属性值每次调用都会增加，直到找不到null,lastIndex==0;
如果不设置全局g,在一个字符串多次调用exec()方法返回的都是第一次匹配的信息，lastIndex==0;
<2>exec、match--不加g没有什么区别(exec的lastIndex永远是0)加上g则match忽略分组直接把总正则全部找出来；
    i--ignoreCase忽略大小写
    m--multiline分行和多行查找(m和表示开头^的元字符一起用才有意义)
<3>元字符：
.	-- 匹配任意字符除了换行符和回车符
[]	-- 匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字
^	-- ^9，这样使用代表匹配以 9 开头。[^9]，这样使用代表不匹配方括号内除了 9 的字符
{1, 2}	-- 匹配 1 到 2 位字符
(yck)	-- 只匹配和 yck 相同字符串
|	-- 匹配 | 前后任意字符
\	-- 转义
*	-- 只匹配出现 0 次及以上 * 前的字符
+	-- 只匹配出现 1 次及以上 + 前的字符
?	-- ? 之前字符可选

\w	-- 匹配字母数字或下划线[a-z][A-Z][0-9]_
\W	-- 和上面相反
\s	-- 匹配任意的空白符(空格，制表符，换页符)
\S	-- 和上面相反
\d	-- 匹配数字
\D	-- 和上面相反
\b	-- 边界boundary,匹配单词的开始或结束
\B	-- 和上面相反
\n	-- 换行
\t	-- 制表符
. 	-- 除换行回车之外的一切字符如果想匹配本身，要加转义字符

<4>表示位置和数量的：^$,+*?{m,n},{m}{m,}
/4+/--/4{1,}/
/4?/--/4{0,1}/
/4*/--/4{0,}/
/4{7}/----连续的7个4
/^4{7}$/----严格匹配7个4，不能出现其他字符
```

> **《1》** `/\d/;==/[0-9]/;[]--表示或--[0-11]`表示从 0 到 1 和 1 不是 11；
> **《2》** `alert(RegExp,$1);`找出存储在 regexp 中的第一个数据`$2`表示第二个;
> **《3》** `/\w/;==/[A-Z][a-z][0-9]_-/;`--要把减号当做字符，要放在中括号中的最后(或者最 前);
> **《4》** `reg=/^[.\n]$/;`带`\`的元字符在`[]`里还是元字符，但是不带`\`的元字符就已经表示此字符了;
> **《5》** `/[^0-9]/^`出现在[]中的第一个位置，表示"非";
> **《6》** 正则表达式的所有元字符都必须转义：元字符包括:` ( [ { \ ^ $ | ) ? * + . ] }`想要匹配字符串中的这些字符就必须进行转义;
> **《7》** 元字符的另一种表示方式(字符串)：------字符串中,`"\"`反斜杠要写成`"\\"`否则把"转义了；
> 字符\在字符串中通常被转义为而在正字表达式字符串中就会变成`\\\\`
> `var reg=new RegExp("\\d");` >**《8》** ()--子表达式，分组
> `/(子正则表达式)\1/`;
> `?:`--表示匹配不捕获`/((?:\d)+1+)/;`
> `woow,4004--reg=/^(\w)(\w)\2\1$/--\2`指的是位置不是数量(子正则表达式位置)相对应重复

### ?: ?=和?! 匹配不捕获
##### 1.理解?=和?!,首先需要理解前瞻，后顾，负前瞻，负后顾四个概念:

**// 前瞻：**
exp1(?=exp2) 查找exp1后面等于exp2的exp1
**// 后顾：**
(?<=exp2)exp1 查找exp1前面等于exp2的exp1
**// 负前瞻：**
exp1(?!exp2) 查找exp1后面不是exp2的exp1
**// 负后顾：**
(?<!exp2)exp1 查找exp1前面不是exp2的exp1

```javascript
/* ?: ?=和?! 匹配不捕获 */
let m1 = "你是chinese人".replace(/你是(?=chinese)/, "我是"); // 匹配"你是chinese人"中的“你是”后面=“chinese”的“你是”，将其替换为我是，结果为：我是chinese人
console.log("exp1(?=exp2)：查找exp1后面等于exp2的exp1", m1);
let m2 = "你是chinese人".replace(/我是(?=chinese)/, "你是"); // 匹配"你是chinese人"中的“我是”后面=“chinese”的“我是”，字符串中chinese前边是你是，所以不能匹配
console.log("?=", m2);
let m = "你是chinese人".replace(/(?<=chinese)人/, " people"); // 匹配"你是chinese人"中的“人”前面=“chinese”的“人”，将其替换为 people，结果为：你是chinese people
console.log("?<=", m);

let n2 = "你是中国人".replace(/你是(?!chinese)/, "我肯定是"); // 匹配"你是chinese人"中"你是"后面非chinese的你是，将其替换为我肯定是，结果为：我肯定是中国人
console.log("exp1(?!exp2) 查找exp1后面不是exp2的exp1", n2);
let n1 = "你是chinese中国人".replace(/你是(?!chinese)/, "，我肯定是"); // 匹配"你是chinese人"中"你是"后面非chinese的你是，字符串中你是后边是chinese，所以不能匹配
console.log("?!", n1);
let n = "你是chinese中国人".replace(/(?<!chinese)人/, "，我是"); // 匹配"你是chinese人"中"人"前面非chinese的中国，将其替换为的，结果为：你是chinese中国，我是
console.log("?<!", n);
```

##### 2.理解?:则需要理解捕获分组和非捕获分组的概念：
`()`表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
`(?:)`表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
 `(?:pattern)`表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来

### 简单应用
```javascript
匹配空白行的正则表达式：\n\s*\r
匹配中文字符的正则表达式： [\u4e00-\u9fa5]
匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />
匹配首尾空白字符的正则表达式：^\s*|\s*$
匹配特定数字：
　　^[1-9]d*$　 　 //匹配正整数
　　^-[1-9]d*$ 　 //匹配负整数
　　^-?[1-9]d*$　　 //匹配整数
　　^[1-9]d*|0$　 //匹配非负整数（正整数 + 0）
　　^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0）
　　^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数
　　^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数
　　^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数
　　^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
　　^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
匹配特定字符串：
　　^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
　　^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
　　^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
　　^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
　　^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串
```
```javascript
// 汉字字符匹配：
var nameReg = /^[\u4E00-\u9FA5]{2,5}(?:·[\u4E00-\u9FA5]{1,26})*$/
// 正则匹配电话：
reg=/^(([+]{0,1}\d{3,4}[ ]?-[ ]?\d{7,8}|\d{11})\s*)*$/
// 简易电话：
/^1[34578]\d{9}$/
// 邮箱验证：
var mainReg = /^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/;
// 身份证验证：
var reg = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
```

## 分组应用
```javascript
// <--第一个方法-->
// 没有分组的话传递三个参数(匹配的结果,匹配到的索引位置,原有的字符串)
var str="23209340928";
    var reg=/^(\d{1,3})((?:\d{3})+)$/;
    // 传递六个参数，?:表示不需要捕获
var str1=str.replace(reg,function(ar0,ar1,ar2){
    // 第一个参数是总正则表达式匹配到的结果
    // 第二个参数是第一个子正则()匹配到的结果
    // 第三个参数为第二个子正则()匹配到的结果
    // ……
    // 倒数第二个参数是总正则表达式在原字符串种匹配到的索引位置
    // 原来的字符串str
    return ar1+ar2.replace(/\d{3}/g,function(rs){
        return ","+rs;
    });
});
// <--第二个方法-->
var str2=str.replace(/\d/g,function(r,i){
    var n=(str.length-1-i)%3;
    if(n==0&&str.length-1-i>0){
        return r+",";
    }
    else{
        return r;
    };
});
// <--第三个方法-->
var strTemp=str.split("").reverse().join("");
//?=pattern正向预查要匹配的字符串后面必须紧跟着pattern
var str3=strTemp.replace(/(\d{3})(?!$)/g,"$1,");
//最后末尾加了一个逗号，倒过来首位就多了一个逗号
str3=str3.split("").reverse().join("");
//正向预查，负向预查
//得到的结尾处有","----正向预查(最后必须满足三位)
```

```javascript
var str = "232093409280";
var reg = /^(\d{1,3})((?:\d{3})+)$/;
var strTemp = str.split("").reverse().join("");
var str3 = strTemp.replace(/(\d{3})(?!$)/g, "$1,");
//匹配的字符串不再末尾就执行，匹配遇到末尾就不匹配了；
str3 = str3.split("").reverse().join("");
console.log(str3);
```

## 应用：数字分隔
javascript 中没有像 vbscript 那样的 trim 函数，我们就可以利用这个表达式来实现
```javascript
String.prototype.trim = function () {
    return this.replace(/(^s*)|(s*$)/g, "");
};
```

## 应用：字符串多个匹配项分隔
```javascript
// 要求吧冒号：后边的字符截取出来
var code = `
    设备型号：XBY-FJ-NN114FS-14
    资产编码：YST20002002
    资产属性：养生堂集团所有
    服务电话：95077
`;
let reg = /(.+?:)：([^\s]*)/g;
let list = code.replace(reg, (...args) => {
    console.log(args);
    return args;
})
console.log(list);
```